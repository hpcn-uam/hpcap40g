#!/bin/bash
# This script generates interactively a configuration file
# for HPCAP based on the current system.

if [ -z "$1" ]; then
	fout="params.cfg"
else
	fout="$1"
fi

fout="$(readlink -f $fout)"

cd "$(dirname ${BASH_SOURCE[0]})"

if [ "$1" = "-h" ]; then
	echo "usage: gen-hpcap-config [target-file]"
	echo "target-file is params.cfg by default"
	exit 0
fi


export PATH=${PATH}:/sbin:./scripts

if ! source hpcap-lib.bash; then
	echo "Shell library (hpcap-lib.bash) not found in your \$PATH nor in the scripts directory"
	echo "Your HPCAP installation is probably corrupted."
	exit 1
fi

ensure_necessary_commands

echo "# Configuration autogenerated by gen-hpcap-config" > $fout
echo "# Timestamp: $(date)" >> $fout
echo >> $fout

read -p "Use basic defaults (no virtual functions, one rx and tx queues)? (y/n) [y]: " yesno

if [[ $yesno =~ ^[Nn]$ ]]; then
	read -p "Use virtual function driver? (y/n) [n]: " yesno

	if [[ $yesno =~ ^[Yy]$ ]]; then
		echo "# Do not use virtual function"
		echo "use_vf=0" >> $fout
	else
		echo "# Use virtual function"
		echo "use_vf=1" >> $fout
	fi

	echo "# RX/TX queues" >> $fout
	read -p "RX queues: " rxq
	echo "nrxq=${rxq}" >> $fout

	read -p "TX queues: " txq
	echo "ntxq=${txq}" >> $fout

	read -p "Consumers per queue: " ncons
	echo "consumers=${ncons}" >> $fout
else
	echo "# Basic defaults (no virtual functions, one rx and tx queues)" >> $fout
	echo "use_vf=0" >> $fout
	echo "nrxq=1" >> $fout
	echo "ntxq=1" >> $fout
	echo "consumers=1" >> $fout
	echo "" >> $fout
fi

read -p "Use hugepages? (y/n) [y]: " yesno

if [[ $yesno =~ ^[Nn]$ ]]; then
	iface_hpcap_mode=2
else
	iface_hpcap_mode=3
	total_hp=$(get_meminfo_val HugePages_Total)

	if [ -z "$total_hp" ] || [ $total_hp -le 0 ]; then
		echor "Error: no hugepages configured in the system. Please read the documentation"
		echor "for information on how to set them up."
		exit 1
	fi

	echo "Your system has $total_hp hugepages available."
	read -p "Input number of pages (of 1G) to assign to each interface [1]: " pagenum

	if [ -z "$pagenum" ]; then
		pagenum=1
	fi

	hugesize="${pagenum}G"
fi


pci_devs=$(find_hpcap_pci_devs)

if [ -z "$pci_devs" ]; then
	echor "Error: No supported PCI devices found. Can't continue."
	exit 1
fi

iface_count=$(echo "$pci_devs" | wc -l)

echo "nif=${iface_count}" >> $fout

echo "Found $iface_count supported interfaces:"

echo "$pci_devs" | awk '{ printf "Port %d: ", NR - 1; system("lspci -s" $1) }'

read -p "Write the ports that you want managed by HPCAP, separated by spaces (if empty, use all interfaces): " hpcap_port_idxs

if [ -z "$hpcap_port_idxs" ]; then
	hpcap_port_idxs=$(seq 0 $((iface_count - 1)))
fi

hpcap_iface_count=$(echo $hpcap_port_idxs | tr ' ' '\n' | wc -l)

if [ $hpcap_iface_count -gt $iface_count ]; then
	echor "There are more interfaces to configure with HPCAP than HPCAP-supported interfaces in the system."
	exit 1
fi

total_hp_to_alloc=$((hpcap_iface_count * pagenum))

if [ $iface_hpcap_mode == "3" ] && [ $total_hp_to_alloc -gt $total_hp ]; then
	echoy "Warning: you will need to increase the number of available hugepages"
	echoy "if you want to use this configuration ($hpcap_iface_count HPCAP interfaces with $pagenum pages for each one)"
fi

max_hpcap_idx=$((iface_count - 1))
ifs_list=""

fixed_page_buffer=$((262144 / $hpcap_iface_count))

hpcap_idx=0

for idx in $(seq 0 $max_hpcap_idx); do
	if listcontains "$hpcap_port_idxs" $idx; then
		iface="hpcap${idx}"
		echo "Port $idx ($iface) configured in HPCAP mode"

		echo "# Port ${idx} configuration - HPCAP" >> $fout
		echo "mode${idx}=$iface_hpcap_mode" >> $fout

		if [ $iface_hpcap_mode == "3" ]; then
			echo "$iface assigned $hugesize hugepage buffer"
			echo "pages${idx}=1" >> $fout
			echo "hugesize${idx}=$hugesize" >> $fout
		else
			echo "$iface assigned $fixed_page_buffer pages of static buffer"
			echo "pages${idx}=$fixed_page_buffer" >> $fout
		fi
	else
		iface="xgb${idx}"
		echo "Port $idx ($iface) configured in non-HPCAP mode"

		echo "# Port ${idx} configuration - non-HPCAP" >> $fout
		echo "mode${idx}=1" >> $fout
		echo "pages${idx}=1" >> $fout
	fi

	echo "vel${idx}=10000" >> $fout
	echo "dup${idx}=0" >> $fout
	echo "caplen${idx}=0" >> $fout
	echo >> $fout

	ifs_list+="$iface "
done

echo "ifs=$ifs_list" >> $fout

# Core configuration
#
# This is programmed a little bit weird, but works. We first
# print the output from numactl, then the reported NUMA node
# for each interface. Awk will parse it and output the parameters
# assigning to each interface the best available core.
#
# It doesn't take into account if there are more interfaces than cores
# (it would be a really absurd situation so it's not worth considering) but
# does notice if there are several cards connected to different NUMA nodes.

echo "# Core configuration" >> $fout

(
	numactl --hardware | grep "cpus: "
	for idx in $(seq 0 $max_hpcap_idx); do
		if listcontains "$hpcap_port_idxs" $idx; then
			pci_id="$(echo "$pci_devs" | awk -vport=$idx 'NR == port + 1 { print $1 }')"
			numa_node="$(cat /sys/bus/pci/devices/0000:${pci_id}/numa_node)"

			if [ -z "$numa_node" ] || [ "$numa_node" -eq -1 ]; then
				echoy "Warning: sysfs returns node -1 for hpcap${idx}. Using default: 0" > /dev/stderr
				numa_node=0
			fi

			echo "$idx $numa_node"
		else
			echo "$idx -1"
		fi
	done
) | awk '
$1 == "node" {
	nodeCpus[$2] = $4
}
$1 != "node" {
	if ($2 == -1) {
		core = -1
	} else {
		core = nodeCpus[$2]
		nodeCpus[$2]++
	}

	printf "core%d=%d\n", $1, core
}' >> $fout

echo >> $fout

read -p "Enable interface monitors? (y/n) [y]: " yesno

echo "# Monitoring" >> $fout
if [[ $yesno =~ ^[Nn]$ ]]; then
	echo "monitor_enabled=0" >> $fout
else
	echo "monitor_enabled=1" >> $fout
fi

echo "monitor_core=-1" >> $fout
echo "monitor_interval=1" >> $fout
echo "monitor_basedir=/var/log/hpcap" >> $fout

echo >> $fout
echo "# Autogenerated config end" >> $fout
